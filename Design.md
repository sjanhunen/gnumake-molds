Core Concepts
=============

Toolchain
---------

A toolchain is a set of tools that are used to translate source code into binary form for execution on a specific architecture.

Code generated by one toolchain cannot be linked or combined with code generated for another toolchain.

Examples: gcc, clang, gcc-debug, clang-release, clang-debug.

While a toolchain must include all tools required to produce an executable binary or library output, the name of the toolchain is generally based upon the compiler.

Generally, debug versus release build variants are handled at the toolchain level due to the significant impact that may be present on generated code.

- `MOSS.TOOLS`: All available toolchains
- `MOSS.TOOL`: Current toolchain

Architecture
------------

A build architecture is defined by a specific CPU type and associated instruction set.

Examples: host, amd64, cortex-m4, cortex-r7, avr, mipsel, etc.

Code generated for different architectures does not interoperate and cannot be linked together.

- `MOSS.ARCHS`: All available architectures for current toolchain
- `MOSS.ARCH`: Current architecture for current toolchain

Good discussion on architecture naming here: http://clang.llvm.org/docs/CrossCompilation.html

Language
--------

Each toolchain supports at least one language that is used by source files.
Many toolchains support multiple languages (e.g. GCC and LLVM).

Globally, language options are configured using the syntax `MOSS.<language>.<option> = <value>`.

Language options can be configured specifically for each spore with the syntax
`<spore>.<language>.<option> = <value>`. For example:

	util.c.defines = POSIX_2001
	util.c.include = util/inc

The spore specific options override any global options. To include the global
Moss options for a specific spore when overriding, simply include the global
options as part of the spore-specific options. For example:

	util.c.defines = $(MOSS.c.defines) UTIL_OPTION_X=1

Spores
------

All outputs are generated from individual units of source code called spores.
Each spore may produce one or more products as outputs during the build
process. Moss manages a list of all spores through the variable
`MOSS.SPORES`. If a new spore is created, it must be added to this list.

For example:

	MOSS.SPORES += util
	util.name = utility
	util.depends = common
	util.products = shared_lib static_lib headers

Spores are defined with the following key variables:

- `<spore>.name` - base name used as part of output products
- `<spore>.depends` - other spores required as dependencies of this spore
- `<spore>.products` - the list of final output products produced by this spore
- `<spore>.source` - the list of source files required to generate products
- `<spore>.headers` - the list of header files to be released with products

Products
--------

Four types of Moss products are currently supported:

- Executable: a fully-linked binary executable
- Static Library: a library for static linking into one or more executables
- Shared Library: a dynamic library for use with one or more executable products
- Headers: a set of header files for stand-alone use or use with a library

Global product options may be configured using the syntax
`MOSS.<product>.<option> = <value>`. For example:

    MOSS.headers.path = include
	MOSS.executable.path = bin/$(MOSS.ARCH)
	MOSS.executable.suffix = .exe
	MOSS.shared_lib.path = lib/$(MOSS.ARCH)
	MOSS.shared_lib.suffix = .so

Spore-specific product options are configured using the syntax `<spore>.<product>.<option> = <value>`.

Dependency Generation
=====================

The only reliable way to get dependencies right with minimal maintenance is to
use the compiler iteself with the same options as an actual build. Otherwise,
there is a risk that preprocessor macros will not be evaluated correctly. 

Reference build with no dependencies:

	Not parallel: 14.229s
	Parallel (-j4): 0m4.096s

Alternatives:

1. Generate dependencies first, one at a time

Not parallel: 0m21.822s
Parallel (-j4): 0m6.318s


2. Generate dependencies after compile, one at a time
Not parallel: 0m19.663s
Parallel (-j4): 0m6.329s  

3. Generate dependencies during compile, one at a time
Not parallel: 0m14.578s
Parallel (-j4): 0m4.217s

3. Generate bulk dependencies for spore first: Not feasable without extra
   post-processing due to the fact that each target needs custom name

Option 3 is the clear winner. For compilers that support dependency generation
during compile (e.g. gcc), this is nearly as fast as a straight build with no
dependency generation. For compilers that don''t support this, the dependency
generation step can be implemented as a separate invocation of the compiler or
other tool during the same recipe for compilation.

One remaining challenge in this design is the performance of make with nothing
to do for large code bases (e.g 10,000 files). Include the per-file dependency
information can take a significant amount of time. For example:

	make: Nothing to be done for 'all'. (no dependencies)

	real    0m0.969s
	user    0m0.312s
	sys     0m0.656s

	make: Nothing to be done for 'all'. (using individual .d files for dependencies)

	real    0m7.629s
	user    0m1.484s
	sys     0m3.406s

The make with nothing to do slows down by nearly an order of magnitude when
full dependency information is used. An experiment was performed to rule out
the performance of include. All dependency files were concatenated into a
single all.d with the following result:

	make: Nothing to be done for 'all'. (using single all.d for dependencies)

	real    0m1.030s
	user    0m0.281s
	sys     0m0.734s

This is a significant performance improvement over including individual
dependency files and represents one path forward for high-performance
dependency generation.

Build Tree Structure
====================

All Moss build object files and products are placed in a Moss build tree
structure called `moss.build` by default.

Build objects and products are placed according to the following guidelines:

- headers -> `MOSS.HEADER.PATH`
- static and shared libraries -> `MOSS.LIBRARY.PATH`
- object files -> `MOSS.OBJECT.PATH`
- executables -> `MOSS.EXECUTABLE.PATH`

Headers located in `MOSS.HEADER.PATH` are automatically included as part of
the system include path when building spore products. Libraries located in
`MOSS.LIB.PATH` are included as part of the library search path when linking
spore products.

An example `moss.build` structure might look something like this:

	moss.build/
		include/
			freertos/
				task.h
				mutex.h
				...
			core/
				stuff.h
				...
			crypto/
				hash.h
				...
		obj/
			armv5.gcc-release/
				crypto/
					src/
						sha1.crypto.o
						md5.crypto.o
				...
			armv5.gcc-debug/
				crypto/
					src/
						sha1.crypto.o
						md5.crypto.o
				...
		bin/
			armv5.gcc-release/
				...
			armv5.gcc-debug/
				...
		lib/
			armv5.gcc-release/
				libfreertos.a
				libcore.a
				libcrypto.a
			armv5.gcc-debug/
				libfreertos.a
				libcore.a
				libcrypto.a

Moss assumes that header files are shared across all architectures and
toolchains. Any architecture-specific header files are an internal
implementation detail of the source code for a spore that defines them.

Recursive vs Inclusive
======================

There are some high-level considerations to make. Do we use any amount of
recursive make to help with iteration over toolchains, architectures, or
possibly even individual spores? It may simplify some things, but the
performance tradeoffs are unknown. As little recursion as possible is the
general design goal.

For example, instead of expanding rules for spores using foreach into a flat
Makefile, it would be possible to invoke a child process to build each spore
using the same rules with variables expanded within each process sandbox. This
could take place in parallel once the spore interdependencies have been
resolved at the top level. An added benefit is that on multi-core machines,
dependency checks for leaf components could take place in parallel.

Without a tangable test, it''s difficult to understand what the performance
tradeoffs would be.

Managing Variants and Configuration
===================================

Likely, these are 3 separate concepts

1. Varieties of spores through inheritance of common variables

2. Configuration of spores through setting of variables (think menuconfig or
kconfig)

3. Selection and application of tool chains for building spores

These concepts should be kept as orthogonal as possible. Likely point 3 is the
only one needed formally right away.

Note that gnumake conditionals may provide a very simple and powerful solution
for configuration:
https://www.gnu.org/software/make/manual/html_node/Conditional-Functions.html

For example

	util.source += $(if util.config.use_gsl, gsl.c)
	util.cflags += $(if util.config.use_gsl, USE_GSL)

If we end up using an inheritance-type pattern for creating varieties of
spores, the configuration approach above would become problematic.
