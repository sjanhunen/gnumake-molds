= Moss Implementation Considerations

This document is a journal of implementation considerations, tradeoffs, and decisions encountered during the implementation of Moss.

== Structure definition

Moss inherently requires groups of related variables to define spores and tools.
One approach to defining these related variables is something like the following.

[source,makefile]
----
M.spores += util
util.name = utility
util.source = util.c helper.c
util.depends = common
util.artifacts = shared_lib static_lib
----

This approach leads to significant duplication and requires that the group is 'registered' using a global list (`M.spores` in this case).

A much cleaner approach is a more traditional structure definition that can automatically be expanded into individual makefile variables using pattern replacement.

[source,makefile]
----
define SPORE/util
  $1.name: utility
  $1.source: util.c helper.c
  $1.depends: common
  $1.artifacts: shared_lib static_lib
endef
----

This eliminates the duplication and is much more readable.
No registration variable is required to register these structures.
They can simply be discovered by name using the path-style prefix.

Error handling may be more difficult or cryptic, since evaluating the definition won't allow a specific line to be cited if make encounters a syntax error.
It may be possible to overcome this issue by expanding each spore definition into a generated makefile that is then included or checked for syntax errors.
Syntax errors in the generated makefile would be easier to and trace back to the original definition.

In the future, it would also be possible to shell out to an external script or tool to convert the structure definition into valid makefile syntax.
Syntax checks and error handling could be done in this step.

== Spores

=== Definition

Spores are defined using a Moss structure with the `SPORE/` prefix.
The structure instance name is present as argument `$1`.

=== Specialization

Gnumake conditionals may provide a very simple and powerful solution
for configuration:
https://www.gnu.org/software/make/manual/html_node/Conditional-Functions.html

For example

[source,makefile]
----
define SPORE/util
  $1.source: $(if $($1.option.use_fpu), fpu.c) common.c
  $1.lang.c.defines: $(if $($1.option.use_fpu), USE_FPU)
endef
----

=== Dependencies

A simple yet elegant way to support libraries compiled from source and pre-built binary libraries is through spore configuration of explicit dependencies.

[source,makefile]
----
define SPORE/util
  # mylib is always linked because it is required by main
  $1.libraries: mylib
  # No dependency if we are using a prebuilt library already in the path
  $1.depends: $(if $($1.option.use_mylib_source), mylib)
endef
----

== Tool Definition

All build actions performed by Moss are defined using tools.

=== Translate

This will be quite similar to compile below.

=== Compile

For example:

[source,makefile]
----
M.tool.compile += gcc
T.gcc.source = %.c
T.gcc.object = %.o
T.gcc.defines = DEFAULT_MOSS

define T.gcc.compile
  gcc \
    $(addprefix -D,$($1.c.defines)) \
    $(addprefix -I,$($1.c.include)) \
    -o $$@ $$^
endef

define T.gcc.depend
  gcc \
    $(addprefix -D,$($1.defines)) \
    $(addprefix -I,$($1.c.include)) \
    -M -o $$@ $$^
endef
-
----

Then, to use particular tools for a particular architecture, simply add the tool to architecture tool selection.

[source,makefile]
----
A.armv5.compile = gcc rustc
# How do we set tool options per architecture?
# Perhaps we could use options like spores.
A.armv5.gcc.arch = armv5
A.armvg.gcc.optimize = 3
----

Language options can be configured specifically for each spore with the syntax
`<spore>.<language>.<option> = <value>`. For example:

	util.c.defines = POSIX_2001
	util.c.include = util/inc

The spore specific options override any global options. To include the global
Moss options for a specific spore when overriding, simply include the global
options as part of the spore-specific options. For example:

	util.c.defines = $(M.lang.c.defines) UTIL_OPTION_X=1


=== Form

Products are registered with Moss when they are added by name to the `M.products` variable.
Global product options are set using the syntax
`M.prod.<name>.<option> = <value>`.
For example, an executable product might look something like this

	M.products += executable
	M.prod.executable.path = $(M.tree.bin)
	# TODO: the toolchain should define the suffix/prefix
	M.prod.executable.prefix =
	M.prod.executable.suffix = .exe
	M.prod.executable.depends = $$($1.objects)

	# Use a multi-line define to support multi-step recipes
	define M.prod.executable.recipe
		$(call M.tool.link, $$<, $$@)
	endef

Another potential approach moves the output definition into the tool definition.
The form definition is really only to establish any dependencies and high-level options.

    # When evaluated, $1 = arch/spore, $2 = toolchain
    M.forms += zip
    M.form.zip.depends = $($1.code)

    # When evaluated, $1 = arch/spore, $2 = toolchain
    M.tool.zip.recipe = zip -cvf $($1.name).zip $($1.code)
    M.tool.zip.suffix = .zip
    M.tool.zip.path = $(M.tree.bin)

Moss manages the silent or debug output of the recipe and allows for customized outputs as the recipe is executed.

Spore-specific form options may be configured using the syntax `<spore>.<form>.<option> = <value>`.

== Spore Specialization

The concept is to allow for flags and options in Spore definition that can be used during expansion of variables.
Inline documentation will make this significantly more managable in large build systems.
For example:

[source,makefile]
----
    base.var.host = host
    base.var.armv4 = ARMv4
    base.var.armv5 = ARMv5

    # Supported flags

    define base.flags.use_fpu.doc
    Enable use of floating point for supported ARM CPUs.
    endef

    define base.flags.inline_mac.doc
    Use inlined MAC code on ARM Cortex M4 for improved performance.
    endef

    # Supported options

    define base.options.cpu_arch.doc
    Specify the CPU target architecture for base library.
    Supported architectures are

    - $(base.var.x86): default ANSI C implementation suitable for most platforms
    - $(base.var.armv4): ARM v4 instruction set
    - $(base.var.armv5): ARM v5 instruction set

    endef
----

When expanding the spore variables, options and flags can be used directly

[source,makefile]
----
    base.source = \
        $(wildcard src/*.cpp) \
        $(wildcard src/$($1.options.cpu_arch)/*.cpp)

    base.c.defines = $(if $($1.flags.use_fpu), USE_FPU)
----

Architecture-specific specializations can also override flags and options

[source,makefile]
----
    # ARM Settings
    armv5/base.flags.use_fpu = y
    armv5/base.options.cpu_arch = $(base.var.armv5)

    # X86 settings
    x86/base.flags.use_fpu = n
    x86/base.options.cpu_arch = $(base.var.host)
----

== Dependency Generation

The most reliable way to get dependencies right with minimal maintenance is to use the compiler iteself with the same options as an actual build.
Otherwise, there is a risk that preprocessor macros will not be evaluated correctly.

Reference build performance with no dependencies:

	Not parallel: 14.229s
	Parallel (-j4): 0m4.096s

Alternatives:

1. Generate dependencies first, one at a time

Not parallel: 0m21.822s
Parallel (-j4): 0m6.318s

2. Generate dependencies after compile, one at a time
Not parallel: 0m19.663s
Parallel (-j4): 0m6.329s

3. Generate dependencies during compile, one at a time
Not parallel: 0m14.578s
Parallel (-j4): 0m4.217s

3. Generate bulk dependencies for spore first: Not feasable without extra
   post-processing due to the fact that each target needs custom name

Option 3 is the clear winner. For compilers that support dependency generation
during compile (e.g. gcc), this is nearly as fast as a straight build with no
dependency generation. For compilers that don''t support this, the dependency
generation step can be implemented as a separate invocation of the compiler or
other tool during the same recipe for compilation.

One remaining challenge in this design is the performance of make with nothing
to do for large code bases (e.g 10,000 files). Include the per-file dependency
information can take a significant amount of time. For example:

	make: Nothing to be done for 'all'. (no dependencies)

	real    0m0.969s
	user    0m0.312s
	sys     0m0.656s

	make: Nothing to be done for 'all'. (using individual .d files for dependencies)

	real    0m7.629s
	user    0m1.484s
	sys     0m3.406s

The make with nothing to do slows down by nearly an order of magnitude when
full dependency information is used. An experiment was performed to rule out
the performance of include. All dependency files were concatenated into a
single all.d with the following result:

	make: Nothing to be done for 'all'. (using single all.d for dependencies)

	real    0m1.030s
	user    0m0.281s
	sys     0m0.734s

This is a significant performance improvement over including individual
dependency files and represents one path forward for high-performance
dependency generation.


== Build Tree Structure

All Moss build object files and products are placed in a Moss build tree
structure called `moss.build` by default.

Build objects and products are placed according to the following guidelines:

- headers -> `M.HEADER.PATH`
- static and shared libraries -> `M.LIBRARY.PATH`
- object files -> `M.OBJECT.PATH`
- executables -> `M.EXECUTABLE.PATH`

Headers located in `M.HEADER.PATH` are automatically included as part of
the system include path when building spore products. Libraries located in
`M.LIB.PATH` are included as part of the library search path when linking
spore products.

An example `moss.build` structure might look something like this:

	moss.build/
		include/
			freertos/
				task.h
				mutex.h
				...
			core/
				stuff.h
				...
			crypto/
				hash.h
				...
		obj/
			armv5.gcc-release/
				crypto/
					src/
						sha1.crypto.o
						md5.crypto.o
				...
			armv5.gcc-debug/
				crypto/
					src/
						sha1.crypto.o
						md5.crypto.o
				...
		bin/
			armv5.gcc-release/
				...
			armv5.gcc-debug/
				...
		lib/
			armv5.gcc-release/
				libfreertos.a
				libcore.a
				libcrypto.a
			armv5.gcc-debug/
				libfreertos.a
				libcore.a
				libcrypto.a

Moss assumes that header files are shared across all architectures and
toolchains. Any architecture-specific header files are an internal
implementation detail of the source code for a spore that defines them.

== Recursive vs Inclusive

There are some high-level considerations to make. Do we use any amount of
recursive make to help with iteration over toolchains, architectures, or
possibly even individual spores? It may simplify some things, but the
performance tradeoffs are unknown. As little recursion as possible is the
general design goal.

For example, instead of expanding rules for spores using foreach into a flat
Makefile, it would be possible to invoke a child process to build each spore
using the same rules with variables expanded within each process sandbox. This
could take place in parallel once the spore interdependencies have been
resolved at the top level. An added benefit is that on multi-core machines,
dependency checks for leaf components could take place in parallel.

If we make use of target-specific variables for toolchain settings, we need to invoke make once recursively on each spore for that target to ensure dependencies are right.

If we simply set toolchain in a top-level invocation of make, we can use that variable in any invocation.

We could also generate spore targets for all toolchains in a single top level invocation.

For example, spore crypto could spawn

	armv5/crypto armv7/crypto host/crypto

By default, linking armv7/app would pick up armv7/crypto. However, this could be overridden with

	armv7/app.depends = armv5/crypto

Toolchain specific dependencies would automatically inherit the appropriate toolchain prefix.

Some use cases may require that toolchain be specialized for certain spores by architecture. That is, a given spore might have to be built a special way for a particular architecture. I think this could be done via target specific variables.
