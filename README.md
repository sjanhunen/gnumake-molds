# gnumake-molds

TODO: rename repository from gnumake-molds to yeast

Goals
=====

Yeast streamlines creation of cross-compiled libraries and executables from
large code bases for a variety of architectures and toolchains using only GNU
make.

Yeast is a build system that is intended for use on a code base stored and
versioned within a single repository. Yeast is not a package manager that
brings together source code and libraries from multiple repositories across
multiple versions. Integration of multiple code bases must either be solved at
a lower level in the repository (e.g. using git submodules) or at a higher
level using a package management system (e.g. Debian packages).

While the final releasable output from a yeast build will likely be a single
library or executable, there are often many intermediate and secondary targets
required to produce this target such as 3rd-party libraries, unit test
executables, special debug and test builds, and so on. Yeast streamlines the
creation and management of these targets.

Features
========

Cross-compiling
---------------

- Cross-compile embedded applications for different architectures with a single Makefile
- Out-of-the-box support for gcc and clang x86/ARM
- Create libaraies with different complier options (e.g. ARM vs Thumb code)

Target generation
-----------------

- Build the same source file with different compiler settings
- Create multiple executable and library target outputs with ease
- Separate definition of program source and structure from creating rules

Large projects
--------------

- Manage large projects with multiple "sub-components"
- Combine components from different parts of a filesystem (re-use installed library source in multiple projects)
- Create release directory structures with libraries, binaries, and includes
- Build against libraries either from source or from released package

Languages
---------

The initial vision is to support core languages in the GCC/LLVM toolchains:

- C
- C++
- Objective C

A longer term vision might be to expand this support to include languages such as

- Rust
- Swift
- Go

Usability
---------

- Tab auto-completion works with targets defined by Mold
- Makes it easier to debug by dumping full commands with options
- Unit testable for validation and performance testing
- Work with in-place object files for the smallest projects
- Support for automatic dependency generation

Key Concepts
============

Toolchain
---------

A toolchain is a set of tools that are used to translate source code into binary form for execution on a specific architecture.

Code generated by one toolchain cannot be linked or combined with code generated for another toolchain.

Examples: gcc, clang, gcc-debug, clang-release, clang-debug.

While a toolchain must include all tools required to produce an executable binary or library output, the name of the toolchain is generally based upon the compiler.

Generally, debug versus release build variants are handled at the toolchain level due to the significant impact that may be present on generated code.

- `YEAST.TOOLS`: All available toolchains
- `YEAST_TOOL`: Current toolchain

Architecture
------------

A build architecture is defined by a specific CPU type and associated instruction set.

Examples: host, amd64, cortex-m4, cortex-r7, avr, mipsel, etc.

Code generated for different architectures does not interoperate and cannot be linked together.

- `YEAST.ARCHS`: All available architectures for current toolchain
- `YEAST_ARCH`: Current architecture for current toolchain

Good discussion on architecture naming here: http://clang.llvm.org/docs/CrossCompilation.html

Spores
------

All output targets are generated from small units called spores. Each spores
may produce one or more buds as outputs. Mold manages a list of all spores
through the variable `YEAST.SPORES`. If a new spore is created, it must be added
to this list.

All spores share the following variables:

- `<spore>.name` - base name used as part of output files
- `<spore>.depends` - other spores required as dependencies of this spore

Dependencies among spores is captured entirely through the above structure.

Buds
----

Three types of buds are currently supported:

- Executable: a fully-linked binary executable
- Library: a library (either static or dynamic)
- Headers: a set of header files for stand-alone use or use with a library

Buds are configured for each spore with the following variable naming convention:

	`<SPORE>.<BUD>.<VARIABLE>`

For example:

	YEAST.SPORES += util
	util.depends = common.headers
	util.lib.source = bob.c larry.c
	util.lib.name = util-bob
	util.headers.source = util.h

Globally, yeast manages options for buds using the following variable naming convention:

	`YEAST.<BUD>.<VARIABLE>`

For example

    YEAST.HEADERS.PATH = include
	YEAST.EXE.PATH = bin/$(YEAST_ARCH)
	YEAST.EXE.SUFFIX = .exe
	YEAST.LIB.PATH = lib/$(YEAST_ARCH)
	YEAST.LIB.SUFFIX = .lib

All targets are placed in a target staging area once created. This keeps the
directory structure organized and enables cleaner integration when multiple
libraries are involved.

Target outputs are staged in the following directories:

	lib -> YEAST.LIB.PATH (e.g. $PREFIX/lib)
	include -> YEAST.HEADER.PATH (e.g. $PREFIX/include)
	exe -> YEAST.EXE.PATH (e.g. $PREFIX/bin)

Headers that are staged into `YEAST.HEADER.PATH` are automatically included as part
of the system include path. Libraries that are staged in `YEAST.LIB.PATH` are
included as part of the library search path. This means that using libraries
created with yeast is identical to using libraries installed in the development
system.

Target Path Organization
========================

A file system example for this might be:

	/opt/mylib
		include
			freertos
			core
			crypto
		bin
			armv5.gcc
			armv5.gcc-debug
		lib
			armv5.gcc
					libfreertos.a
					libcore.a
					libcrypto.a
			armv5.gcc-debug
					libcore.a
					libcrypto.a

Object File Organization
========================

Object files may be built in place with the source tree or may be built out of
place in a separate `OBJ_DIR`. If compiled in place, the convention is

In-place object file naming convention:

	<SOURCE_PATH>/<SOURCE_BASENAME>.<YEAST_SPORE>.<YEAST_ARCH>.<YEAST_TOOL>.<YEAST.OBJ.SUFFIX>

Out-of-place object file naming convention:

	<YEAST.OBJ.PATH>/<SOURCE_PATH>/<SOURCE_BASENAME>.<YEAST_TARGET>.<YEAST_ARCH>.<YEAST_TOOL>.<YEAST.OBJ.SUFFIX>

Object file examples:

	my_file.core_bare.arm-cm3.gcc-debug.o
	my_file.core_bare.arm-cm3.llvm-debug.o
	my_file.core_bare.host.gcc.o
	my_file.core_freertos.cortex-m3.gcc-release.o

