# gnumake-molds
Molds for building software with GNU make

Goals
=====

Cross-compiling:

- Cross-compile embedded applications for different architectures with a single Makefile
- Out-of-the-box support for gcc and clang x86/ARM
- Create libaraies with different complier options (e.g. ARM vs Thumb code)

Target generation:

- Build the same source file with different compiler settings
- Create multiple executable and library target outputs with ease
- Separate definition of program source and structure from creating rules

Large software projects:

- Manage large projects with multiple "sub-components"
- Combine components from different parts of a filesystem (re-use installed library source in multiple projects)
- Create release directory structures with libraries, binaries, and includes
- Build against library components from either source or released binary


Usability:

- Tab auto-completion works with targets defined by Mold
- Makes it easier to debug by dumping full commands with options
- Unit testable for validation and performance testing
- Work with in-place object files for the smallest projects
- Support for automatic dependency generation


Key Concepts
============

Toolchain
---------

A toolchain is a set of tools that are used to translate source code into binary form for execution on a specific architecture.

Code generated by one toolchain cannot be linked or combined with code generated for another toolchain.

Examples: gcc, clang, gcc-debug, clang-release, clang-debug.

While a toolchain must include all tools required to produce an executable binary or library output, the name of the toolchain is generally based upon the compiler.

Generally, debug versus release build variants are handled at the toolchain level due to the significant impact that may be present on generated code.

All available toolchains: MOLD_TOOLS
Current toolchain: MOLD_TOOL

Architecture
------------

A build architecture is defined by a specific CPU type and associated instruction set.

Examples: host, amd64, cortex-m4, cortex-r7, avr, mipsel, etc.

Code generated for different architectures does not interoperate and cannot be linked together.

All available architectures for current toolchain: MOLD_ARCHS
Current architecture for current toolchain: MOLD_ARCH

Good discussion on architecture naming here: http://clang.llvm.org/docs/CrossCompilation.html

Target
------

A target is the definition of a single linked binary and/or library output.

Different targets may compile the same source files with different compiler settings. But all targets for a given architecture and variant are compatible at a link level, even if it may not make sense to actuall link them together for a usable result.

All targets for current toolchain and architecture: MOLD_TARGETS

Object File Organization
========================

Object files may be built in place with the source tree or may be built out of place in a separate OBJ_DIR. If compiled in place, the convention is

In-place object file naming convention:

	<SOURCE_PATH>/<SOURCE_BASENAME>.<MOLD_TARGET>.<MOLD_ARCH>.<MOLD_TOOL>.<MOLD_OBJ_EXT>

Out-of-place object file naming convention:

	<MOLD_OBJDIR>/<SOURCE_PATH>/<SOURCE_BASENAME>.<MOLD_TARGET>.<MOLD_ARCH>.<MOLD_TOOL>.<MOLD_OBJ_EXT>

Object file examples:

	my_file.core_bare.arm-cm3.gcc-debug.o
	my_file.core_bare.arm-cm3.llvm-debug.o
	my_file.core_bare.host.gcc.o
	my_file.core_freertos.cortex-m3.gcc-release.o

Library and binary file examples:

	libcore_bare.arm-cm3.gcc-debug.ar


Release file structure examples:

	<MOLD_RELDIR>/

		<TOOL>/

			include/
				<ARCH>/
				<ARCH>/

			lib-<ARCH>/

			bin-<ARCH>/