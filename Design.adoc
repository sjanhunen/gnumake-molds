Moss Design Overview
====================

This document captures the core design decisions and concepts for the MOSS build system.

Toolchain
---------

A toolchain is a set of tools that are used to translate source code into binary form for execution on a specific architecture.

Toolchain settings are chosen based upon architecture and variant. Additional customization may be overlaid for each spore based upon architecture.

Code generated by one toolchain cannot be linked or combined with code generated for another toolchain.

Examples: gcc, clang, gcc-debug, clang-release, clang-debug.

While a toolchain must include all tools required to produce an executable binary or library output, the name of the toolchain is generally based upon the compiler.

Generally, debug versus release build variants are handled at the toolchain level due to the significant impact that may be present on generated code.

- `MOSS.TOOLS`: All available toolchains
- `MOSS.TOOL`: Current toolchain

A toolchain uses both architecture and variant to customize settings to the specific code generation tools.

Architecture
------------

An architecture definition specifies a toolchain. For example armv5-gcc would specify a gcc cross compiler. And armv5-clang would specify a clang cross compile. In order to build the same spore for the same processor with two different tools, two different architectures must be created.

Architecture is the mechanism for customized compilation of spores for a particular target. Different spores compiled for the same architecture may have different toolchain settings. The architecture is the means of selection. Spores compiled for the same architecture may be linked together. A mixing of architectures is not supported.

A build architecture is defined by a specific CPU type and associated instruction set.

Examples: host, amd64, cortex-m4, cortex-r7, avr, mipsel, etc.

Code generated for different architectures does not interoperate and cannot be linked together.

- `MOSS.ARCHS`: All available architectures for current toolchain
- `MOSS.ARCH`: Current architecture for current toolchain

Good discussion on architecture naming here: http://clang.llvm.org/docs/CrossCompilation.html

Variant
-------

A build variant is a selection that applies across all architectures and toolchains (in most cases). An example would be debug vs production.

Variants provide the mechanism for compiling multiple spores for the same architecture with different collections of settings that apply to all spores. Example use cases that apply here are debug, production, or special test build variants.

Language
--------

Each toolchain supports at least one language that is used by source files.
Many toolchains support multiple languages (e.g. GCC and LLVM).

Globally, language options are configured using the syntax `MOSS.<language>.<option> = <value>`.

Language options can be configured specifically for each spore with the syntax
`<spore>.<language>.<option> = <value>`. For example:

	util.c.defines = POSIX_2001
	util.c.include = util/inc

The spore specific options override any global options. To include the global
Moss options for a specific spore when overriding, simply include the global
options as part of the spore-specific options. For example:

	util.c.defines = $(MOSS.c.defines) UTIL_OPTION_X=1

Spores
------

All outputs are generated from individual units of source code called spores.
Each spore may produce one or more products as outputs during the build
process. Moss manages a list of all spores through the variable
`MOSS.SPORES`. If a new spore is created, it must be added to this list.

Defining spores:

- done entirely through variables
- configuration done only through conditional assignment (not with if statements)
- no knowledge of tool chain or compiler specifics is specified (expect for architecture-specific sections)

For example:

	MOSS.SPORES += util
	util.name = utility
	util.depends = common
	util.products = shared_lib static_lib headers

Can we only list the desired end targets in MOSS.SPORES and use dependencies to figure out the rest?

Spores are defined with the following key variables:

- `<spore>.name` - base name used as part of output products
- `<spore>.depends` - other spores required as dependencies of this spore
- `<spore>.products` - the list of final output products produced by this spore
- `<spore>.source` - the list of source files required to generate products
- `<spore>.headers` - the list of header files to be released with products

A simple yet elegant way to support libraries compiled from source and pre-built binary libraries is through spore configuration of explicit dependencies.

	# mylib is always linked because it is required by main
	main.libraries = mylib
	# No dependency if we are using a prebuilt library already in the path
	main.depends = if($1.config.use_mylib_source, mylib)

Products
--------

Four types of Moss products are currently supported:

- Executable: a fully-linked binary executable
- Static Library: a library for static linking into one or more executables
- Shared Library: a dynamic library for use with one or more executable products
- Headers: a set of header files for stand-alone use or use with a library

Global product options may be configured using the syntax
`MOSS.<product>.<option> = <value>`. For example:

	MOSS.headers.path = include
	MOSS.executable.path = bin/$(MOSS.ARCH)
	MOSS.executable.suffix = .exe
	MOSS.shared_lib.path = lib/$(MOSS.ARCH)
	MOSS.shared_lib.suffix = .so

Spore-specific product options are configured using the syntax `<spore>.<product>.<option> = <value>`.




Managing Variants and Configuration
===================================

Likely, these are 3 separate concepts

1. Varieties of spores through inheritance of common variables

2. Configuration of spores through setting of variables (think menuconfig or
kconfig)

3. Selection and application of tool chains for building spores

These concepts should be kept as orthogonal as possible. Likely point 3 is the
only one needed formally right away.

Note that gnumake conditionals may provide a very simple and powerful solution
for configuration:
https://www.gnu.org/software/make/manual/html_node/Conditional-Functions.html

For example

	util.source += $(if $1.config.use_gsl, gsl.c)
	util.cflags += $(if $1.config.use_gsl, USE_GSL)

To use an inheritance-type pattern, it''s necessary to make use of the $1
expansion rather than hard-coding the config variable name. A prototype needs
to be done to fully vet this concept.

If we end up using an inheritance-type pattern for creating varieties of
spores, the configuration approach above would become problematic.
