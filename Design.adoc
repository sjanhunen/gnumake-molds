Moss Design Overview
====================

This document captures the core design decisions and concepts that define the Moss build system.

Spores
------

The spore is the fundamental unit of modular software description and construction in Moss.
A spore describes how Moss creates binary products from source files in an architecture and toolchain independent fashion.

Spores are defined entirely through a series of variable definitions. Creation and management of rules and dependencies is completely managed by moss.
Knowledge of toolchain, compiler, or architecture specifics are decoupled from the description of the software itself.
This avoids many pitfalls of tradational make-based build systems.

A product is produced by combining object files or other product files into a library or binary output.
Each spore may produce one or more products as outputs during the build process.

Each spore is compiled and linked in its own 'sandbox'.
This guarantees that object and binary files will never be clobbered, even if multiple spores use the same source file compiled in different ways.

The fundamental actions defined for creation of spore output products are:

- Translate: product or source -> source
- Compile: source -> object
- Produce: object(s) + product(s) -> product

Moss manages the creation and application of these rules for multiple architectures, toolchains, and variants.

Three types of products are envisioned:

- Executable: a fully-linked binary executable
- Static Library: a library for static linking into one or more executables
- Shared Library: a dynamic library for use with one or more executable products

Concepts for managing spore varieties and configuration switches:

1. Varieties of spores through inheritance of common variables

2. Configuration of spores through setting of variables (think menuconfig or kconfig)

3. Selection and application of tool chains for building spores.

These concepts should be kept as orthogonal as possible. Likely point 3 is the only one needed formally right away.

Toolchain
---------

A toolchain is a set of tools that are used to translate source code into binary form for execution on a specific architecture.

Toolchain settings are chosen based upon architecture and variant. Additional customization may be overlaid for each spore based upon architecture.

Code generated by one toolchain cannot be linked or combined with code generated for another toolchain.

Examples: gcc, clang, gcc-debug, clang-release, clang-debug.

While a toolchain must include all tools required to produce an executable binary or library output, the name of the toolchain is generally based upon the compiler.

Generally, debug versus release build variants are handled at the toolchain level due to the significant impact that may be present on generated code.

- `MOSS.TOOLS`: All available toolchains
- `MOSS.TOOL`: Current toolchain

A toolchain uses both architecture and variant to customize settings to the specific code generation tools.

Architecture
------------

An architecture definition specifies a toolchain. For example armv5-gcc would specify a gcc cross compiler. And armv5-clang would specify a clang cross compile. In order to build the same spore for the same processor with two different tools, two different architectures must be created.

Architecture is the mechanism for customized compilation of spores for a particular target. Different spores compiled for the same architecture may have different toolchain settings. The architecture is the means of selection. Spores compiled for the same architecture may be linked together. A mixing of architectures is not supported.

A build architecture is defined by a specific CPU type and associated instruction set.

Examples: host, amd64, cortex-m4, cortex-r7, avr, mipsel, etc.

Code generated for different architectures does not interoperate and cannot be linked together.

- `MOSS.ARCHS`: All available architectures for current toolchain
- `MOSS.ARCH`: Current architecture for current toolchain

Good discussion on architecture naming here: http://clang.llvm.org/docs/CrossCompilation.html

Variant
-------

A build variant is a selection that applies across all architectures and toolchains (in most cases). An example would be debug vs production.

Variants provide the mechanism for compiling multiple spores for the same architecture with different collections of settings that apply to all spores. Example use cases that apply here are debug, production, or special test build variants.

Language
--------

Each toolchain supports at least one language that is used by source files.
Many toolchains support multiple languages (e.g. GCC and LLVM).

Globally, language options are configured using the syntax `MOSS.<language>.<option> = <value>`.

Language options can be configured specifically for each spore with the syntax
`<spore>.<language>.<option> = <value>`. For example:

	util.c.defines = POSIX_2001
	util.c.include = util/inc

The spore specific options override any global options. To include the global
Moss options for a specific spore when overriding, simply include the global
options as part of the spore-specific options. For example:

	util.c.defines = $(MOSS.c.defines) UTIL_OPTION_X=1
