= Moss Design Overview

Moss is a library for GNU make that streamlines the creation of large-scale multi-platform software builds.

Moss manages the creation of all makefile rules and dependencies required for multiple languages, build artifacts, platforms, toolchains, and variants.
Knowledge of toolchain and platform specifics are decoupled from the description of the software itself.

== Core Concepts

The design of Moss is based on five core concepts:

1. Seed - granular, configurable unit of definition
2. Artifact - completed software build output
3. Tool - translates code, compiles code, or forms an artifact
3. Platform - specializes artifacts and tools for target environment
5. Variant - specializes tools for build types

These concepts enforce a healthy separation of concerns but still allow for flexible combinations.
This separation of concerns avoids many pitfalls of traditional makefile-based build systems.

== Seeds

Seeds are a coherent collection of definitions that may be used by to define and customize artifacts for multiple platforms.
A given seed may be used to produce multiple artifacts for multiple platforms without requiring duplication of the seed definition itself.
The platform-specific specializations are created from the base seed template.
Platform-specific options and overrides can be specified through variables that overload the base definition for the seed.

== Artifacts

Each completed software build output is defined as an artifact.
Common examples would include libraries and executables.
Artifacts may be defined directly without using seeds if specialization is not required across platforms.
Artifacts that are specialized for specific platforms make use of seeds for configuration.

Most artifacts will require creation of object files using a compiler as part of the recipe.
Each artifact is built in an isolated sandbox.
This guarantees that object and artifact files will never be clobbered, even if multiple artifacts use the source code in different ways.

== Platforms

A platform defines the aspects of the target execution environment that impact any generated artifact machine code.
This includes CPU hardware architecture along with other relevant environment details such as OS or RTOS.
For embedded applications, hardware architecture often has additional board-specific or chipset-specific details baked into it.
While it may be tempting to think of platforms as CPU architectures, they really should be considered application-specific.
Each application will define the specific platforms that are relevant.

== Tools

Tool are used to create all build artifacts.
Tools perform one of three possible actions:

1. Translate: convert source code from one language from another language. The output is generated source code, not object code.

2. Compile: converts source code into object code.  The output is object code.

3. Form: Create final artifact output. An artifact may contain source files or object code. Some artifacts may be produced directly from source files.

A tool does not possess any knowledge of build platform or variant.
Instead, tools are specialized through both platform and variant by setting appropriate tool options to form artifacts appropriately.

== Variants

A build variant is an orthogonal concept to target platform.
Variants are the specialization mechanism for forming artifacts on the same platform with different tool settings.
Example use cases that apply here are debug, production, or special test build variants.
Another use case may be building the same artifact for the same platform with different tools (e.g. clang vs gcc).
